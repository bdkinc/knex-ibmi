{"version":3,"sources":["../src/index.ts","../src/schema/ibmi-compiler.ts","../src/schema/ibmi-tablecompiler.ts","../src/schema/ibmi-columncompiler.ts","../src/execution/ibmi-transaction.ts","../src/query/ibmi-querycompiler.ts","../src/migrations/ibmi-migration-runner.ts"],"sourcesContent":["import process from \"node:process\";\nimport knex, { Knex } from \"knex\";\nimport odbc, { Connection } from \"odbc\";\nimport SchemaCompiler from \"./schema/ibmi-compiler\";\nimport TableCompiler from \"./schema/ibmi-tablecompiler\";\nimport ColumnCompiler from \"./schema/ibmi-columncompiler\";\nimport Transaction from \"./execution/ibmi-transaction\";\nimport QueryCompiler from \"./query/ibmi-querycompiler\";\nimport { Readable } from \"node:stream\";\nimport {\n  IBMiMigrationRunner,\n  createIBMiMigrationRunner,\n} from \"./migrations/ibmi-migration-runner\";\n\ninterface QueryObject {\n  response?: {\n    rows: any[];\n    rowCount: number;\n  };\n  sqlMethod: SqlMethod;\n  output?: (runner: any, response: any) => any;\n  pluck?: (row: any) => any;\n  select?: boolean;\n}\n\nenum SqlMethod {\n  SELECT = \"select\",\n  PLUCK = \"pluck\",\n  FIRST = \"first\",\n  INSERT = \"insert\",\n  DELETE = \"del\",\n  DELETE_ALT = \"delete\",\n  UPDATE = \"update\",\n  COUNTER = \"counter\",\n}\n\nclass DB2Client extends knex.Client {\n  constructor(config: Knex.Config<DB2Config>) {\n    console.log(\"🎯 DB2Client constructor called!\");\n    super(config);\n    this.driverName = \"odbc\";\n\n    if (this.dialect && !this.config.client) {\n      this.printWarn(\n        `Using 'this.dialect' to identify the client is deprecated and support for it will be removed in the future. Please use configuration option 'client' instead.`\n      );\n    }\n\n    const dbClient = this.config.client || this.dialect;\n    if (!dbClient) {\n      throw new Error(\n        `knex: Required configuration option 'client' is missing.`\n      );\n    }\n\n    if (config.version) {\n      this.version = config.version;\n    }\n\n    if (this.driverName && config.connection) {\n      this.initializeDriver();\n      if (!config.pool || (config.pool && config.pool.max !== 0)) {\n        this.initializePool(config);\n      }\n    }\n\n    this.valueForUndefined = this.raw(\"DEFAULT\");\n    if (config.useNullAsDefault) {\n      this.valueForUndefined = null;\n    }\n  }\n\n  // Helper method to safely stringify objects that might have circular references\n  private safeStringify(obj: any, indent: number = 0): string {\n    try {\n      return JSON.stringify(obj, null, indent);\n    } catch (error) {\n      if (error instanceof Error && error.message.includes(\"circular\")) {\n        return `[Circular structure - ${typeof obj}]`;\n      }\n      return `[Stringify error - ${typeof obj}]`;\n    }\n  }\n\n  _driver() {\n    return odbc;\n  }\n\n  wrapIdentifierImpl(value: string) {\n    // override default wrapper (\")\n    // we don't want to use it since\n    // it makes identifier case-sensitive in DB2\n\n    // Fix case sensitivity issues for IBM i migration tables\n    // Normalize migration-related table names to be consistent\n    if (\n      value.includes(\"KNEX_MIGRATIONS\") ||\n      value.includes(\"knex_migrations\")\n    ) {\n      // Ensure migration table names are uppercase for consistency\n      return value.toUpperCase();\n    }\n\n    return value;\n  }\n\n  printDebug(message: string) {\n    if (process.env.DEBUG === \"true\") {\n      if (this.logger.debug) {\n        this.logger.debug(\"knex-ibmi: \" + message);\n      }\n    }\n  }\n\n  printError(message: string) {\n    if (this.logger.error) {\n      this.logger.error(\"knex-ibmi: \" + message);\n    }\n  }\n\n  printWarn(message: string) {\n    if (process.env.DEBUG === \"true\") {\n      if (this.logger.warn) {\n        this.logger.warn(\"knex-ibmi: \" + message);\n      }\n    }\n  }\n\n  // Get a raw connection, called by the pool manager whenever a new\n  // connection needs to be added to the pool.\n  async acquireRawConnection() {\n    this.printDebug(\"acquiring raw connection\");\n    const connectionConfig = this.config.connection as DB2ConnectionConfig;\n\n    if (!connectionConfig) {\n      return this.printError(\"There is no connection config defined\");\n    }\n\n    this.printDebug(\n      \"connection config: \" + this._getConnectionString(connectionConfig)\n    );\n\n    let connection: Connection;\n\n    if (this.config?.pool) {\n      const poolConfig = {\n        connectionString: this._getConnectionString(connectionConfig),\n        connectionTimeout: this.config?.acquireConnectionTimeout || 60000,\n        initialSize: this.config?.pool?.min || 2,\n        maxSize: this.config?.pool?.max || 10,\n        reuseConnection: true,\n      };\n      const pool = await this.driver.pool(poolConfig);\n      connection = await pool.connect();\n    } else {\n      connection = await this.driver.connect(\n        this._getConnectionString(connectionConfig)\n      );\n    }\n\n    return connection;\n  }\n\n  // Used to explicitly close a connection, called internally by the pool manager\n  // when a connection times out or the pool is shutdown.\n  async destroyRawConnection(connection: any) {\n    this.printDebug(\"destroy connection\");\n    return await connection.close();\n  }\n\n  _getConnectionString(connectionConfig: DB2ConnectionConfig) {\n    const connectionStringParams =\n      connectionConfig.connectionStringParams || {};\n\n    const connectionStringExtension = Object.keys(\n      connectionStringParams\n    ).reduce((result, key) => {\n      const value = connectionStringParams[key];\n      return `${result}${key}=${value};`;\n    }, \"\");\n\n    return (\n      `DRIVER=${connectionConfig.driver};` +\n      `SYSTEM=${connectionConfig.host};` +\n      `HOSTNAME=${connectionConfig.host};` +\n      `PORT=${connectionConfig.port};` +\n      `DATABASE=${connectionConfig.database};` +\n      `UID=${connectionConfig.user};` +\n      `PWD=${connectionConfig.password};` +\n      connectionStringExtension\n    );\n  }\n\n  // Runs the query on the specified connection, providing the bindings\n  async _query(connection: Connection, obj: any) {\n    const queryObject = this.normalizeQueryObject(obj);\n    const method = this.determineQueryMethod(queryObject);\n    queryObject.sqlMethod = method;\n\n    // Debug migration queries (only if DEBUG environment variable is set)\n    if (\n      process.env.DEBUG === \"true\" &&\n      queryObject.sql &&\n      (queryObject.sql.toLowerCase().includes(\"create table\") ||\n        queryObject.sql.toLowerCase().includes(\"knex_migrations\"))\n    ) {\n      this.printDebug(\n        `Executing ${method} query: ${queryObject.sql.substring(0, 200)}...`\n      );\n      if (queryObject.bindings?.length) {\n        this.printDebug(`Bindings: ${JSON.stringify(queryObject.bindings)}`);\n      }\n    }\n\n    try {\n      const startTime = Date.now();\n      if (this.isSelectMethod(method)) {\n        await this.executeSelectQuery(connection, queryObject);\n      } else {\n        await this.executeStatementQuery(connection, queryObject);\n      }\n      const endTime = Date.now();\n\n      if (\n        process.env.DEBUG === \"true\" &&\n        queryObject.sql &&\n        (queryObject.sql.toLowerCase().includes(\"create table\") ||\n          queryObject.sql.toLowerCase().includes(\"knex_migrations\"))\n      ) {\n        this.printDebug(`${method} completed in ${endTime - startTime}ms`);\n      }\n\n      this.printDebug(`Query completed: ${method} (${endTime - startTime}ms)`);\n      return queryObject;\n    } catch (error: any) {\n      // Enhanced error handling for connection issues\n      if (this.isConnectionError(error)) {\n        this.printError(\n          `Connection error during ${method} query: ${error.message}`\n        );\n\n        // For critical migration operations, retry once before failing\n        if (queryObject.sql?.toLowerCase().includes(\"systables\")) {\n          this.printDebug(\"Retrying hasTable query due to connection error...\");\n          try {\n            // Wait a moment and retry the query\n            await new Promise((resolve) => setTimeout(resolve, 1000));\n            if (this.isSelectMethod(method)) {\n              await this.executeSelectQuery(connection, queryObject);\n            } else {\n              await this.executeStatementQuery(connection, queryObject);\n            }\n            return queryObject;\n          } catch (retryError: any) {\n            this.printError(`Retry failed: ${retryError.message}`);\n            // If retry fails, return empty result to prevent migration corruption\n            queryObject.response = { rows: [], rowCount: 0 };\n            return queryObject;\n          }\n        }\n\n        throw new Error(\n          `Connection closed during ${method} operation - IBM i DB2 DDL operations cause implicit commits`\n        );\n      }\n      throw error;\n    }\n  }\n\n  private normalizeQueryObject(obj: any): any {\n    if (!obj || typeof obj === \"string\") {\n      return { sql: obj };\n    }\n    return obj;\n  }\n\n  private determineQueryMethod(obj: any): string {\n    return (\n      obj.hasOwnProperty(\"method\") && obj.method !== \"raw\"\n        ? obj.method\n        : obj.sql.split(\" \")[0]\n    ).toLowerCase();\n  }\n\n  private isSelectMethod(method: string): boolean {\n    return method === \"select\" || method === \"first\" || method === \"pluck\";\n  }\n\n  private async executeSelectQuery(\n    connection: Connection,\n    obj: { sql: string; bindings: any[]; response: unknown }\n  ): Promise<void> {\n    const rows: Record<any, any>[] = await connection.query(\n      obj.sql,\n      obj.bindings\n    );\n    if (rows) {\n      obj.response = { rows, rowCount: rows.length };\n    }\n  }\n\n  private async executeStatementQuery(\n    connection: Connection,\n    obj: any\n  ): Promise<void> {\n    let statement: any;\n    try {\n      statement = await connection.createStatement();\n      await statement.prepare(obj.sql);\n\n      if (obj.bindings) {\n        await statement.bind(obj.bindings);\n      }\n\n      const result = await statement.execute();\n      this.printDebug(String(result));\n\n      obj.response = this.formatStatementResponse(result);\n    } catch (err: any) {\n      // Special handling for UPDATE/DELETE queries that affect 0 rows\n      // Some ODBC drivers signal 0-row DML via empty error/\"no data\" (SQLSTATE 02000)\n      const sql = (obj.sql || \"\").toLowerCase();\n      const isDml =\n        obj.sqlMethod === SqlMethod.UPDATE ||\n        sql.includes(\" update \") ||\n        sql.startsWith(\"update\") ||\n        obj.sqlMethod === SqlMethod.DELETE ||\n        sql.includes(\" delete \") ||\n        sql.startsWith(\"delete\");\n\n      const odbcErrors = err?.odbcErrors;\n      const isEmptyOdbcError =\n        Array.isArray(odbcErrors) && odbcErrors.length === 0;\n      const hasNoDataState = Array.isArray(odbcErrors)\n        ? odbcErrors.some(\n            (e: any) =>\n              String(e?.state || e?.SQLSTATE || \"\").toUpperCase() === \"02000\"\n          )\n        : false;\n\n      if (\n        isDml &&\n        (isEmptyOdbcError || hasNoDataState || this.isNoDataError(err))\n      ) {\n        this.printWarn(\n          `ODBC signaled no-data for ${sql.includes(\"update\") ? \"UPDATE\" : \"DELETE\"}; treating as 0 rows affected`\n        );\n        obj.response = { rows: [], rowCount: 0 };\n        return;\n      }\n\n      this.printError(this.safeStringify(err));\n      throw err;\n    } finally {\n      // Ensure statement is closed to avoid resource leaks/hangs\n      if (statement && typeof statement.close === \"function\") {\n        try {\n          await statement.close();\n        } catch (closeErr) {\n          // Ignore close errors, log in debug mode only\n          this.printDebug(\n            `Error closing statement: ${this.safeStringify(closeErr, 2)}`\n          );\n        }\n      }\n    }\n  }\n\n  private isNoDataError(error: any): boolean {\n    if (!error) return false;\n    const msg = String(error?.message || error || \"\").toLowerCase();\n    // Match common indicators of 0-row DML reported as error\n    return (\n      msg.includes(\"02000\") ||\n      msg.includes(\"no data\") ||\n      msg.includes(\"no rows\") ||\n      msg.includes(\"0 rows\")\n    );\n  }\n\n  /**\n   * Format statement response from ODBC driver\n   * Handles special case for IDENTITY_VAL_LOCAL() function\n   */\n  private formatStatementResponse(result: any): {\n    rows: any;\n    rowCount: number;\n  } {\n    const isIdentityQuery = result.statement?.includes(\"IDENTITY_VAL_LOCAL()\");\n\n    if (isIdentityQuery && result.columns?.length > 0) {\n      return {\n        rows: result.map(\n          (row: { [x: string]: any }) => row[result.columns[0].name]\n        ),\n        rowCount: result.count,\n      };\n    }\n\n    // Normalize result for DML (UPDATE/DELETE/INSERT) to surface rowCount consistently\n    const rowCount = typeof result?.count === \"number\" ? result.count : 0;\n    return {\n      rows: result,\n      rowCount,\n    };\n  }\n\n  async _stream(\n    connection: Connection,\n    obj: { sql: string; bindings: any[] },\n    stream: any,\n    options: {\n      fetchSize?: number;\n    }\n  ) {\n    if (!obj.sql) throw new Error(\"A query is required to stream results\");\n\n    return new Promise((resolve, reject) => {\n      stream.on(\"error\", reject);\n      stream.on(\"end\", resolve);\n\n      connection.query(\n        obj.sql,\n        obj.bindings,\n        {\n          cursor: true,\n          fetchSize: options?.fetchSize || 1,\n        },\n        (error, cursor) => {\n          if (error) {\n            this.printError(this.safeStringify(error, 2));\n            stream.emit(\"error\", error);\n            reject(error);\n            return;\n          }\n\n          const readableStream = this._createCursorStream(cursor);\n          readableStream.on(\"error\", (err) => {\n            reject(err);\n            stream.emit(\"error\", err);\n          });\n          readableStream.pipe(stream);\n        }\n      );\n    });\n  }\n\n  private _createCursorStream(cursor: any): Readable {\n    const parentThis = this;\n    return new Readable({\n      objectMode: true,\n      read() {\n        cursor.fetch((error: unknown, result: unknown) => {\n          if (error) {\n            parentThis.printError(parentThis.safeStringify(error, 2));\n          }\n\n          if (!cursor.noData) {\n            this.push(result);\n          } else {\n            cursor.close((closeError: unknown) => {\n              if (closeError) {\n                parentThis.printError(JSON.stringify(closeError, null, 2));\n              }\n              if (result) {\n                this.push(result);\n              }\n              this.push(null); // End the stream\n            });\n          }\n        });\n      },\n    });\n  }\n\n  transaction(container: any, config: any, outerTx: any): Knex.Transaction {\n    return new (Transaction as any)(this, container, config, outerTx);\n  }\n\n  schemaCompiler(tableBuilder: any) {\n    return new (SchemaCompiler as any)(this, tableBuilder);\n  }\n\n  tableCompiler(tableBuilder: any) {\n    return new (TableCompiler as any)(this, tableBuilder);\n  }\n\n  columnCompiler(tableCompiler: any, columnCompiler: any) {\n    return new (ColumnCompiler as any)(this, tableCompiler, columnCompiler);\n  }\n\n  queryCompiler(builder: Knex.QueryBuilder, bindings?: any[]) {\n    return new (QueryCompiler as any)(this, builder, bindings);\n  }\n\n  // Create IBM i-specific migration runner that bypasses Knex's problematic locking system\n  createMigrationRunner(\n    config?: Partial<\n      import(\"./migrations/ibmi-migration-runner\").IBMiMigrationConfig\n    >\n  ) {\n    // Pass the knex instance from the client context\n    const knexInstance = (this as any).context || (this as any);\n    return createIBMiMigrationRunner(knexInstance, config);\n  }\n\n  processResponse(obj: QueryObject | null, runner: any): any {\n    if (obj === null) return null;\n\n    const { response } = obj;\n\n    // If there's a custom output function, use it directly without validation\n    // This allows custom queries like hasTable to handle their own response format\n    if (obj.output) {\n      try {\n        const result = obj.output(runner, response);\n        return result;\n      } catch (error: any) {\n        // Enhanced error handling for custom output functions\n        this.printError(\n          `Custom output function failed: ${error.message || error}`\n        );\n        if (this.isConnectionError(error)) {\n          throw new Error(\n            \"Connection closed during query processing - consider using migrations.disableTransactions: true for DDL operations\"\n          );\n        }\n        throw error;\n      }\n    }\n\n    // Only validate for standard SQL methods that expect rows structure\n    const validationResult = this.validateResponse(obj);\n    if (validationResult !== null) return validationResult;\n\n    return this.processSqlMethod(obj);\n  }\n\n  private validateResponse(obj: QueryObject): any {\n    if (!obj.response) {\n      this.printDebug(\"response undefined\" + JSON.stringify(obj));\n      return null;\n    }\n\n    // For non-select methods, it's fine if rows is empty/undefined as long as rowCount is set.\n    // Do not short-circuit here; allow processSqlMethod to normalize the return value.\n\n    if (!obj.response.rows) {\n      this.printError(\"rows undefined\" + JSON.stringify(obj));\n      return null;\n    }\n\n    return null;\n  }\n\n  private isConnectionError(error: any): boolean {\n    const errorMessage = (\n      error.message ||\n      error.toString ||\n      error\n    ).toLowerCase();\n    return (\n      errorMessage.includes(\"connection\") &&\n      (errorMessage.includes(\"closed\") ||\n        errorMessage.includes(\"invalid\") ||\n        errorMessage.includes(\"terminated\") ||\n        errorMessage.includes(\"not connected\"))\n    );\n  }\n\n  private processSqlMethod(obj: QueryObject): any {\n    const { rows, rowCount } = obj.response!;\n\n    switch (obj.sqlMethod) {\n      case SqlMethod.SELECT:\n        return rows;\n      case SqlMethod.PLUCK:\n        return rows.map(obj.pluck!);\n      case SqlMethod.FIRST:\n        return rows[0];\n      case SqlMethod.INSERT:\n        return rows;\n      case SqlMethod.DELETE:\n      case SqlMethod.DELETE_ALT:\n      case SqlMethod.UPDATE:\n        // Align with MySQL: return affected rows as a number for DML\n        return obj.select ? rows : (rowCount ?? 0);\n      case SqlMethod.COUNTER:\n        return rowCount;\n      default:\n        return rows;\n    }\n  }\n}\n\ninterface DB2PoolConfig {\n  min?: number;\n  max?: number;\n  acquireConnectionTimeout?: number;\n}\n\ninterface DB2ConnectionParams {\n  CMT?: number;\n  CONNTYPE?: number;\n  DBQ?: string;\n  MAXDECPREC?: 31 | 63;\n  MAXDECSCALE?: number;\n  MINDIVSCALE?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;\n  NAM?: 0 | 1;\n  DFT?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7;\n  DSP?: 0 | 1 | 2 | 3 | 4;\n  DEC?: 0 | 1;\n  DECFLOATERROROPTION?: 0 | 1;\n  DECFLOATROUNDMODE?: 0 | 1 | 2 | 3 | 4 | 5 | 6;\n  MAPDECIMALFLOATDESCRIBE?: 1 | 3;\n  TFT?: 0 | 1 | 2 | 3 | 4;\n  TSP?: 0 | 1 | 2 | 3;\n  TSFT?: 0 | 1;\n  XMLCURIMPPARSE?: 0 | 1;\n  XMLDECLARATION?: 1 | 2 | 3 | 4;\n  ALLOWPROCCALLS?: 0 | 1;\n  XDYNAMIC?: 0 | 1;\n  DFTPKGLIB?: string;\n  PKG?: 0 | 1 | 2;\n  BLOCKFETCH?: 0 | 1;\n  COMPRESSION?: 0 | 1;\n  CONCURRENCY?: 0 | 1;\n  CURSORSENSITIVITY?: 0 | 1 | 2;\n  EXTCOLINFO?:\n    | \"SQL_DESC_AUTO_UNIQUE_VALUE\"\n    | \"SQL_DESC_BASE_COLUMN_NAME\"\n    | \"SQL_DESC_BASE_TABLE_NAME and SQL_DESC_TABLE_NAME\"\n    | \"SQL_DESC_LABEL\"\n    | \"SQL_DESC_SCHEMA_NAME\"\n    | \"SQL_DESC_SEARCHABLE\"\n    | \"SQL_DESC_UNNAMED\"\n    | \"SQL_DESC_UPDATABLE\";\n  TRUEAUTOCOMMIT?: 0 | 1;\n}\n\ninterface DB2ConnectionConfig {\n  database: string;\n  host: string;\n  port: 8471 | 9471 | number;\n  user: string;\n  password: string;\n  driver: \"IBM i Access ODBC Driver\" | string;\n  connectionStringParams?: DB2ConnectionParams;\n}\n\nexport interface DB2Config extends Knex.Config {\n  client: any;\n  connection: DB2ConnectionConfig;\n  pool?: DB2PoolConfig;\n}\n\nexport const DB2Dialect = DB2Client;\nexport { IBMiMigrationRunner, createIBMiMigrationRunner };\nexport default DB2Client;\n","import SchemaCompiler from \"knex/lib/schema/compiler.js\";\n\nclass IBMiSchemaCompiler extends SchemaCompiler {\n  // Use type assertion to work around ESM import interface issues\n  [key: string]: any;\n\n  hasTable(tableName: string) {\n    const upperName = String(tableName).toUpperCase();\n\n    // Extract schema and table name if qualified\n    let schemaName: string | null = null;\n    let actualTableName = upperName;\n\n    if (upperName.includes(\".\")) {\n      const parts = upperName.split(\".\");\n      schemaName = parts[0];\n      actualTableName = parts[1];\n    }\n\n    // Use schema from the builder if available\n    const builderSchema = (this.builder as any)._schema;\n    if (builderSchema) {\n      schemaName = builderSchema.toUpperCase();\n    }\n\n    let sql: string;\n    let bindings: any[];\n\n    if (schemaName) {\n      sql = `select count(*) as table_count from QSYS2.SYSTABLES where UPPER(TABLE_NAME) = ? AND UPPER(TABLE_SCHEMA) = ?`;\n      bindings = [actualTableName, schemaName];\n    } else {\n      sql = `select count(*) as table_count from QSYS2.SYSTABLES where UPPER(TABLE_NAME) = ?`;\n      bindings = [actualTableName];\n    }\n\n    this.pushQuery({\n      sql,\n      bindings,\n      output: (runner: any, resp: any) => {\n        // Handle the response from the ODBC query\n        // The first parameter is the runner, the second is the actual response\n        if (!resp) {\n          return false;\n        }\n\n        // Check if response is an array with results\n        if (Array.isArray(resp) && resp.length > 0) {\n          const firstRow = resp[0];\n          if (firstRow && typeof firstRow === \"object\") {\n            // Look for table_count or any count field\n            const count =\n              firstRow.table_count ||\n              firstRow.TABLE_COUNT ||\n              firstRow.count ||\n              firstRow.COUNT ||\n              0;\n            return count > 0;\n          }\n        }\n\n        // Handle ODBC response format with numeric keys\n        if (typeof resp === \"object\" && resp !== null) {\n          // Check for ODBC array-like response with numeric indices\n          const keys = Object.keys(resp);\n          for (const key of keys) {\n            if (!isNaN(parseInt(key))) {\n              const row = resp[key];\n              if (row && typeof row === \"object\") {\n                const count =\n                  row.table_count ||\n                  row.TABLE_COUNT ||\n                  row.count ||\n                  row.COUNT ||\n                  0;\n                return count > 0;\n              }\n            }\n          }\n\n          // Handle response with rows property\n          if (resp.rows && Array.isArray(resp.rows) && resp.rows.length > 0) {\n            const firstRow = resp.rows[0];\n            if (firstRow && typeof firstRow === \"object\") {\n              const count =\n                firstRow.table_count ||\n                firstRow.TABLE_COUNT ||\n                firstRow.count ||\n                firstRow.COUNT ||\n                0;\n              return count > 0;\n            }\n          }\n        }\n\n        return false;\n      },\n    });\n  }\n\n  toSQL() {\n    const sequence = (this.builder as any)._sequence as any[];\n\n    for (let i = 0, l = sequence.length; i < l; i++) {\n      const query = sequence[i];\n      this[query.method].apply(this, query.args);\n    }\n\n    return this.sequence;\n  }\n}\n\nfunction prefixedTableName(prefix: any, table: any) {\n  return prefix ? `${prefix}.${table}` : table;\n}\n\nexport default IBMiSchemaCompiler;\n","import TableCompiler from \"knex/lib/schema/tablecompiler.js\";\nimport { Connection } from \"odbc\";\n\nclass IBMiTableCompiler extends TableCompiler {\n  // Use type assertion to work around ESM import interface issues\n  [key: string]: any;\n\n  createQuery(columns: { sql: any[] }, ifNot: any, like: any) {\n    let createStatement = ifNot\n      ? `if object_id('${this.tableName()}', 'U') is null `\n      : \"\";\n\n    if (like) {\n      // This query copy only columns and not all indexes and keys like other databases.\n      createStatement += `select * into ${this.tableName()} from ${this.tableNameLike()} WHERE 0=1`;\n    } else {\n      createStatement +=\n        \"create table \" +\n        this.tableName() +\n        (this._formatting ? \" (\\n    \" : \" (\") +\n        columns.sql.join(this._formatting ? \",\\n    \" : \", \") +\n        this._addChecks() +\n        \")\";\n    }\n\n    this.pushQuery(createStatement);\n\n    if (this.single.comment) {\n      this.comment(this.single.comment);\n    }\n\n    if (like) {\n      this.addColumns(columns, this.addColumnsPrefix);\n    }\n  }\n\n  dropUnique(columns: string[], indexName: any) {\n    indexName = indexName\n      ? this.formatter.wrap(indexName)\n      : this._indexCommand(\"unique\", this.tableNameRaw, columns);\n\n    this.pushQuery(`drop index ${indexName}`);\n  }\n\n  unique(\n    columns: string[],\n    indexName:\n      | string\n      | { indexName?: string; deferrable?: string; predicate?: any }\n  ) {\n    let deferrable: string = \"\";\n    let predicate: any;\n    let finalIndexName: string | undefined;\n\n    if (typeof indexName === \"object\" && indexName !== null) {\n      deferrable = indexName.deferrable || \"\";\n      predicate = indexName.predicate;\n      finalIndexName = indexName.indexName;\n    } else {\n      finalIndexName = indexName;\n    }\n\n    if (deferrable && deferrable !== \"not deferrable\") {\n      this.client.logger.warn?.(\n        `IBMi: unique index \\`${finalIndexName}\\` will not be deferrable ${deferrable}.`\n      );\n    }\n\n    const wrappedIndexName = finalIndexName\n      ? this.formatter.wrap(finalIndexName)\n      : this._indexCommand(\"unique\", this.tableNameRaw, columns);\n    columns = this.formatter.columnize(columns);\n\n    const predicateQuery = predicate\n      ? \" \" + this.client.queryCompiler(predicate).where()\n      : \"\";\n\n    this.pushQuery(\n      `create unique index ${wrappedIndexName} on ${this.tableName()} (${columns})${predicateQuery}`\n    );\n  }\n\n  // All of the columns to \"add\" for the query\n  addColumns(columns: any, prefix: any) {\n    prefix = prefix || this.addColumnsPrefix;\n\n    if (columns.sql.length > 0) {\n      const columnSql = columns.sql.map((column) => {\n        return prefix + column;\n      });\n      this.pushQuery({\n        sql:\n          (this.lowerCase ? \"alter table \" : \"ALTER TABLE \") +\n          this.tableName() +\n          \" \" +\n          columnSql.join(\" \"),\n        bindings: columns.bindings,\n      });\n    }\n  }\n\n  async commit(connection: Connection) {\n    return await connection.commit();\n  }\n}\n\nexport default IBMiTableCompiler;\n","import ColumnCompiler from \"knex/lib/schema/columncompiler.js\";\n\nclass IBMiColumnCompiler extends ColumnCompiler {\n  // Use type assertion to work around ESM import interface issues\n  [key: string]: any;\n\n  increments(options = { primaryKey: true }) {\n    return (\n      \"int not null generated always as identity (start with 1, increment by 1)\" +\n      (this.tableCompiler._canBeAddPrimaryKey(options) ? \" primary key\" : \"\")\n    );\n  }\n}\n\nexport default IBMiColumnCompiler;\n","import Transaction from \"knex/lib/execution/transaction.js\";\n\nclass IBMiTransaction extends Transaction {\n  // Use type assertion to work around ESM import interface issues\n  [key: string]: any;\n\n  begin(connection: any): any {\n    try {\n      return connection.beginTransaction();\n    } catch (error: any) {\n      if (this.isConnectionClosed(error)) {\n        console.warn(\n          \"IBM i DB2: Connection closed during transaction begin, DDL operations may have caused implicit commit\"\n        );\n        throw new Error(\n          \"Connection closed during transaction begin - consider using migrations.disableTransactions: true\"\n        );\n      }\n      throw error;\n    }\n  }\n\n  rollback(connection: any): any {\n    try {\n      return connection.rollback();\n    } catch (error: any) {\n      // Treat rollback on a closed connection as success to avoid hangs\n      console.warn(\n        \"IBM i DB2: Rollback encountered an error (likely closed connection):\",\n        error?.message || error\n      );\n      return Promise.resolve();\n    }\n  }\n\n  commit(connection: any): any {\n    try {\n      return connection.commit();\n    } catch (error: any) {\n      if (this.isConnectionClosed(error)) {\n        console.warn(\n          \"IBM i DB2: Connection closed during commit - DDL operations cause implicit commits\"\n        );\n        // Re-throw so Knex can surface the expected failure semantics\n        throw new Error(\n          \"Connection closed during commit - this is expected with DDL operations on IBM i DB2\"\n        );\n      }\n      throw error;\n    }\n  }\n\n  private isConnectionClosed(error: any): boolean {\n    const message = String(error?.message || error || \"\").toLowerCase();\n    return (\n      message.includes(\"connection\") &&\n      (message.includes(\"closed\") ||\n        message.includes(\"invalid\") ||\n        message.includes(\"terminated\") ||\n        message.includes(\"not connected\"))\n    );\n  }\n}\n\nexport default IBMiTransaction;\n","import QueryCompiler from \"knex/lib/query/querycompiler.js\";\nimport { rawOrFn as rawOrFn_ } from \"knex/lib/formatter/wrappingFormatter.js\";\n\nclass IBMiQueryCompiler extends QueryCompiler {\n  // Use type assertion to work around ESM import interface issues\n  [key: string]: any;\n\n  private formatTimestampLocal(date: Date): string {\n    const pad = (n: number) => String(n).padStart(2, \"0\");\n    const y = date.getFullYear();\n    const m = pad(date.getMonth() + 1);\n    const d = pad(date.getDate());\n    const hh = pad(date.getHours());\n    const mm = pad(date.getMinutes());\n    const ss = pad(date.getSeconds());\n    return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;\n  }\n  insert() {\n    const insertValues = this.single.insert || [];\n    const { returning } = this.single;\n\n    // Handle empty insert values\n    if (this.isEmptyInsertValues(insertValues)) {\n      if (this.isEmptyObject(insertValues)) {\n        return this.buildEmptyInsertResult(returning);\n      }\n      return \"\";\n    }\n\n    // Build the complete INSERT statement wrapped in SELECT from FINAL TABLE\n    const selectColumns = returning\n      ? this.formatter.columnize(returning)\n      : \"IDENTITY_VAL_LOCAL()\";\n\n    const returningSql = returning\n      ? this._returning(\"insert\", returning, undefined) + \" \"\n      : \"\";\n\n    const insertSql = [\n      this.with(),\n      `insert into ${this.tableName}`,\n      this._buildInsertData(insertValues, returningSql),\n    ]\n      .filter(Boolean)\n      .join(\" \");\n\n    const sql = `select ${selectColumns} from FINAL TABLE(${insertSql})`;\n\n    return { sql, returning };\n  }\n\n  private isEmptyInsertValues(insertValues: any): boolean {\n    return (\n      (Array.isArray(insertValues) && insertValues.length === 0) ||\n      this.isEmptyObject(insertValues)\n    );\n  }\n\n  private isEmptyObject(insertValues: any): boolean {\n    return (\n      insertValues !== null &&\n      typeof insertValues === \"object\" &&\n      !Array.isArray(insertValues) &&\n      Object.keys(insertValues).length === 0\n    );\n  }\n\n  private buildEmptyInsertResult(returning: any): {\n    sql: string;\n    returning: any;\n  } {\n    const selectColumns = returning\n      ? this.formatter.columnize(returning)\n      : \"IDENTITY_VAL_LOCAL()\";\n\n    const returningSql = returning\n      ? this._returning(\"insert\", returning, undefined) + \" \"\n      : \"\";\n\n    const insertSql = [\n      this.with(),\n      `insert into ${this.tableName}`,\n      returningSql + this._emptyInsertValue,\n    ]\n      .filter(Boolean)\n      .join(\" \");\n\n    const sql = `select ${selectColumns} from FINAL TABLE(${insertSql})`;\n\n    return { sql, returning };\n  }\n\n  _buildInsertData(insertValues: string | any[], returningSql: string): string {\n    const insertData = this._prepInsert(insertValues);\n\n    // Handle case with columns and data\n    if (insertData.columns.length > 0) {\n      const columnsSql = `(${this.formatter.columnize(insertData.columns)})`;\n      const valuesSql = `(${this._buildInsertValues(insertData)})`;\n      return `${columnsSql} ${returningSql}values ${valuesSql}`;\n    }\n\n    // Handle a single empty object case\n    if (\n      Array.isArray(insertValues) &&\n      insertValues.length === 1 &&\n      insertValues[0]\n    ) {\n      return returningSql + this._emptyInsertValue;\n    }\n\n    // Handle empty/invalid data\n    return \"\";\n  }\n\n  _prepInsert(data: any): { columns: any; values: any } {\n    // Handle timestamps in knex migrations\n    if (typeof data === \"object\" && data?.migration_time) {\n      const parsed = new Date(data.migration_time);\n      if (!isNaN(parsed.getTime())) {\n        data.migration_time = this.formatTimestampLocal(parsed);\n      }\n    }\n\n    const isRaw = rawOrFn_(\n      data,\n      undefined,\n      this.builder,\n      this.client,\n      this.bindingsHolder\n    );\n\n    if (isRaw) {\n      return isRaw;\n    }\n\n    // Normalize data to array format\n    const dataArray = Array.isArray(data) ? data : data ? [data] : [];\n\n    if (dataArray.length === 0) {\n      return { columns: [], values: [] };\n    }\n\n    // Get all unique columns from all data objects\n    const allColumns = new Set<string>();\n    for (const item of dataArray) {\n      if (item != null) {\n        Object.keys(item).forEach((key) => allColumns.add(key));\n      }\n    }\n\n    const columns = Array.from(allColumns).sort();\n    const values: any[] = [];\n\n    // Build values array\n    for (const item of dataArray) {\n      if (item == null) {\n        break;\n      }\n\n      const row = columns.map((column) => item[column] ?? undefined);\n      values.push(row);\n    }\n\n    return {\n      columns,\n      values,\n    };\n  }\n\n  update(): { sql: string; returning: any } {\n    const withSQL = this.with();\n    const updates = this._prepUpdate(this.single.update);\n    const where = this.where();\n    const order = this.order();\n    const limit = this.limit();\n    const { returning } = this.single;\n\n    // Build the base update statement\n    const baseUpdateSql = [\n      withSQL,\n      `update ${this.single.only ? \"only \" : \"\"}${this.tableName}`,\n      \"set\",\n      updates.join(\", \"),\n      where,\n      order,\n      limit,\n    ]\n      .filter(Boolean)\n      .join(\" \");\n\n    // Handle returning clause\n    if (returning) {\n      this.client.logger.warn?.(\n        \"IBMi DB2 does not support returning in update statements, only inserts\"\n      );\n      const selectColumns = this.formatter.columnize(this.single.returning);\n      const sql = `select ${selectColumns} from FINAL TABLE(${baseUpdateSql})`;\n      return { sql, returning };\n    }\n\n    return { sql: baseUpdateSql, returning };\n  }\n\n  /**\n   * Handle returning clause for IBMi DB2 queries\n   * Note: IBMi DB2 has limited support for RETURNING clauses\n   * @param method - The SQL method (insert, update, delete)\n   * @param value - The returning value\n   * @param withTrigger - Trigger support (currently unused)\n   */\n  _returning(method: string, value: any, withTrigger: undefined) {\n    switch (method) {\n      case \"update\":\n      case \"insert\":\n        return value ? `${withTrigger ? \" into #out\" : \"\"}` : \"\";\n      case \"del\":\n        return value ? `${withTrigger ? \" into #out\" : \"\"}` : \"\";\n      case \"rowcount\":\n        return value ? \"select @@rowcount\" : \"\";\n      default:\n        return \"\";\n    }\n  }\n\n  columnizeWithPrefix(prefix: string, target: string | string[]) {\n    const columns = typeof target === \"string\" ? [target] : target;\n    let str = \"\";\n    let i = -1;\n\n    while (++i < columns.length) {\n      if (i > 0) str += \", \";\n      str += prefix + this.wrap(columns[i]);\n    }\n\n    return str;\n  }\n}\n\nexport default IBMiQueryCompiler;\n","import fs from \"fs\";\nimport path from \"path\";\nimport { Knex } from \"knex\";\n\nexport interface IBMiMigrationConfig {\n  directory: string;\n  tableName: string;\n  schemaName?: string;\n  extension?: string;\n}\n\nexport class IBMiMigrationRunner {\n  private knex: Knex;\n  private config: IBMiMigrationConfig;\n\n  constructor(knex: Knex, config?: Partial<IBMiMigrationConfig>) {\n    this.knex = knex;\n\n    // Default configuration\n    this.config = {\n      directory: \"./migrations\",\n      tableName: \"KNEX_MIGRATIONS\",\n      schemaName: undefined,\n      extension: \"js\",\n      ...config,\n    };\n  }\n\n  private getFullTableName(): string {\n    return this.config.schemaName\n      ? `${this.config.schemaName}.${this.config.tableName}`\n      : this.config.tableName;\n  }\n\n  async latest(): Promise<void> {\n    try {\n      console.log(\n        \"🚀 IBM i DB2 Migration Runner - bypassing Knex locking system\"\n      );\n\n      // Ensure the migration table exists\n      const tableName = this.getFullTableName();\n\n      const migrationTableExists = await (this.knex as any).schema.hasTable(\n        tableName\n      );\n      if (!migrationTableExists) {\n        console.log(`📝 Creating migration table: ${tableName}`);\n        await (this.knex as any).schema.createTable(tableName, (table) => {\n          table.increments(\"id\").primary();\n          table.string(\"name\");\n          table.integer(\"batch\");\n          table.timestamp(\"migration_time\");\n        });\n        console.log(\"✅ Migration table created\");\n      }\n\n      // Get completed migrations (IBM i uses uppercase column names)\n      const completed = await this.knex(tableName).select(\"NAME\").orderBy(\"ID\");\n      const completedNames = completed.map((c: any) => c.NAME);\n      console.log(`📋 Found ${completedNames.length} completed migrations`);\n\n      // Get migration files\n      const migrationFiles = this.getMigrationFiles();\n      console.log(`📁 Found ${migrationFiles.length} migration files`);\n\n      // Find new migrations to run\n      const newMigrations = migrationFiles.filter(\n        (file) => !completedNames.includes(file)\n      );\n\n      if (newMigrations.length === 0) {\n        console.log(\"✅ No new migrations to run\");\n        return;\n      }\n\n      console.log(`🎯 Running ${newMigrations.length} new migrations:`);\n      newMigrations.forEach((file) => console.log(`  - ${file}`));\n\n      // Get next batch number (IBM i uses uppercase column names)\n      const batchResult = await this.knex(tableName).max(\"BATCH as max_batch\");\n      const nextBatch = (batchResult[0]?.max_batch || 0) + 1;\n      console.log(`📊 Using batch number: ${nextBatch}`);\n\n      // Run each migration\n      for (const migrationFile of newMigrations) {\n        console.log(`\\n🔄 Running migration: ${migrationFile}`);\n\n        try {\n          // Import the migration\n          const migrationPath = this.getMigrationPath(migrationFile);\n          const migration = await import(migrationPath);\n\n          if (!migration.up || typeof migration.up !== \"function\") {\n            throw new Error(`Migration ${migrationFile} has no 'up' function`);\n          }\n\n          // Execute the migration\n          console.log(`  ⚡ Executing migration...`);\n          await migration.up(this.knex);\n\n          // Record the migration\n          await this.knex(tableName).insert({\n            name: migrationFile,\n            batch: nextBatch,\n            migration_time: new Date(),\n          });\n\n          console.log(`  ✅ Migration ${migrationFile} completed successfully`);\n        } catch (error: any) {\n          console.error(\n            `  ❌ Migration ${migrationFile} failed:`,\n            error.message\n          );\n          throw error;\n        }\n      }\n\n      console.log(`\\n🎉 All migrations completed successfully!`);\n    } catch (error: any) {\n      console.error(\"❌ Migration runner failed:\", error.message);\n      throw error;\n    }\n  }\n\n  async rollback(steps: number = 1): Promise<void> {\n    try {\n      console.log(`🔄 Rolling back ${steps} migration batch(es)...`);\n\n      const tableName = this.getFullTableName();\n\n      // Get the last batch(es) to rollback\n      const batchesToRollback = await this.knex(tableName)\n        .distinct(\"BATCH\")\n        .orderBy(\"BATCH\", \"desc\")\n        .limit(steps);\n\n      if (batchesToRollback.length === 0) {\n        console.log(\"✅ No migrations to rollback\");\n        return;\n      }\n\n      const batchNumbers = batchesToRollback.map((b: any) => b.BATCH);\n      console.log(`📊 Rolling back batches: ${batchNumbers.join(\", \")}`);\n\n      // Get migrations to rollback\n      const migrationsToRollback = await this.knex(tableName)\n        .select(\"NAME\")\n        .whereIn(\"BATCH\", batchNumbers)\n        .orderBy(\"ID\", \"desc\");\n\n      console.log(`🎯 Rolling back ${migrationsToRollback.length} migrations:`);\n      migrationsToRollback.forEach((m: any) => console.log(`  - ${m.NAME}`));\n\n      // Rollback each migration\n      for (const migrationRecord of migrationsToRollback) {\n        const migrationFile = migrationRecord.NAME;\n        console.log(`\\n🔄 Rolling back migration: ${migrationFile}`);\n\n        try {\n          // Import the migration\n          const migrationPath = this.getMigrationPath(migrationFile);\n          const migration = await import(migrationPath);\n\n          if (migration.down && typeof migration.down === \"function\") {\n            console.log(`  ⚡ Executing rollback...`);\n            await migration.down(this.knex);\n          } else {\n            console.log(\n              `  ⚠️ Migration ${migrationFile} has no 'down' function, skipping rollback`\n            );\n          }\n\n          // Remove the migration record\n          await this.knex(tableName).where(\"NAME\", migrationFile).del();\n\n          console.log(\n            `  ✅ Migration ${migrationFile} rolled back successfully`\n          );\n        } catch (error: any) {\n          console.error(\n            `  ❌ Migration ${migrationFile} rollback failed:`,\n            error.message\n          );\n          throw error;\n        }\n      }\n\n      console.log(`\\n🎉 Rollback completed successfully!`);\n    } catch (error: any) {\n      console.error(\"❌ Rollback failed:\", error.message);\n      throw error;\n    }\n  }\n\n  async currentVersion(): Promise<string | null> {\n    try {\n      const tableName = this.getFullTableName();\n\n      const migrationTableExists = await (this.knex as any).schema.hasTable(\n        tableName\n      );\n      if (!migrationTableExists) {\n        return null;\n      }\n\n      const result = await this.knex(tableName)\n        .select(\"NAME\")\n        .orderBy(\"ID\", \"desc\")\n        .first();\n\n      return result?.NAME || null;\n    } catch (error: any) {\n      console.error(\"❌ Error getting current version:\", error.message);\n      return null;\n    }\n  }\n\n  async listExecuted(): Promise<string[]> {\n    try {\n      const tableName = this.getFullTableName();\n\n      const migrationTableExists = await (this.knex as any).schema.hasTable(\n        tableName\n      );\n      if (!migrationTableExists) {\n        return [];\n      }\n\n      const completed = await this.knex(tableName).select(\"NAME\").orderBy(\"ID\");\n      return completed.map((c: any) => c.NAME);\n    } catch (error: any) {\n      console.error(\"❌ Error listing executed migrations:\", error.message);\n      return [];\n    }\n  }\n\n  async listPending(): Promise<string[]> {\n    try {\n      const allFiles = this.getMigrationFiles();\n      const executed = await this.listExecuted();\n      return allFiles.filter((file) => !executed.includes(file));\n    } catch (error: any) {\n      console.error(\"❌ Error listing pending migrations:\", error.message);\n      return [];\n    }\n  }\n\n  private getMigrationFiles(): string[] {\n    const { directory, extension } = this.config;\n\n    if (!fs.existsSync(directory)) {\n      throw new Error(`Migration directory does not exist: ${directory}`);\n    }\n\n    // Support multiple extensions by checking for common migration file extensions\n    const validExtensions = ['js', 'ts', 'mjs', 'cjs'];\n    const extensionToCheck = extension || 'js';\n    \n    return fs\n      .readdirSync(directory)\n      .filter((file) => {\n        // If a specific extension is configured, use only that\n        if (extension && extension !== 'js') {\n          return file.endsWith(`.${extension}`);\n        }\n        // Otherwise, check for any valid migration extension\n        return validExtensions.some(ext => file.endsWith(`.${ext}`));\n      })\n      .sort();\n  }\n\n  private getMigrationPath(filename: string): string {\n    return path.resolve(this.config.directory, filename);\n  }\n}\n\n// Export a factory function for easy instantiation\nexport function createIBMiMigrationRunner(\n  knex: Knex,\n  config?: Partial<IBMiMigrationConfig>\n): IBMiMigrationRunner {\n  return new IBMiMigrationRunner(knex, config);\n}\n"],"mappings":"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","names":["knex"]}